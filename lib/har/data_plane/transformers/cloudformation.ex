# SPDX-License-Identifier: MPL-2.0
defmodule HAR.DataPlane.Transformers.CloudFormation do
  @moduledoc """
  Transformer for AWS CloudFormation template format (YAML/JSON).

  Converts HAR semantic graph to CloudFormation templates.

  ## Features

  - EC2 instances, Auto Scaling Groups
  - S3 buckets
  - Lambda functions
  - RDS databases
  - VPC networking (VPCs, Subnets, Security Groups)
  - IAM roles and policies
  - DynamoDB tables
  - ECS/EKS resources
  - Load balancers
  - DependsOn from semantic graph dependencies
  """

  @behaviour HAR.DataPlane.Transformer

  alias HAR.Semantic.Graph
  require Logger

  # Semantic operation to CloudFormation resource type mapping
  @type_mappings %{
    vm_create: "AWS::EC2::Instance",
    vm_template_create: "AWS::EC2::LaunchTemplate",
    autoscaler_create: "AWS::AutoScaling::AutoScalingGroup",
    function_create: "AWS::Lambda::Function",
    container_service_create: "AWS::ECS::Service",
    container_task_create: "AWS::ECS::TaskDefinition",
    container_cluster_create: "AWS::ECS::Cluster",
    kubernetes_cluster_create: "AWS::EKS::Cluster",
    kubernetes_nodegroup_create: "AWS::EKS::Nodegroup",
    storage_bucket_create: "AWS::S3::Bucket",
    storage_volume_create: "AWS::EBS::Volume",
    storage_filesystem_create: "AWS::EFS::FileSystem",
    database_create: "AWS::RDS::DBInstance",
    database_cluster_create: "AWS::RDS::DBCluster",
    database_table_create: "AWS::DynamoDB::Table",
    cache_create: "AWS::ElastiCache::CacheCluster",
    network_vpc_create: "AWS::EC2::VPC",
    network_subnet_create: "AWS::EC2::Subnet",
    network_route_table_create: "AWS::EC2::RouteTable",
    network_route_create: "AWS::EC2::Route",
    network_gateway_create: "AWS::EC2::InternetGateway",
    network_nat_create: "AWS::EC2::NatGateway",
    security_group_create: "AWS::EC2::SecurityGroup",
    network_eip_create: "AWS::EC2::EIP",
    load_balancer_create: "AWS::ElasticLoadBalancingV2::LoadBalancer",
    load_balancer_target_create: "AWS::ElasticLoadBalancingV2::TargetGroup",
    load_balancer_listener_create: "AWS::ElasticLoadBalancingV2::Listener",
    dns_zone_create: "AWS::Route53::HostedZone",
    dns_record_create: "AWS::Route53::RecordSet",
    cdn_create: "AWS::CloudFront::Distribution",
    api_gateway_create: "AWS::ApiGateway::RestApi",
    role_create: "AWS::IAM::Role",
    policy_create: "AWS::IAM::Policy",
    user_create: "AWS::IAM::User",
    group_create: "AWS::IAM::Group",
    instance_profile_create: "AWS::IAM::InstanceProfile",
    notification_topic_create: "AWS::SNS::Topic",
    queue_create: "AWS::SQS::Queue",
    event_rule_create: "AWS::Events::Rule",
    alarm_create: "AWS::CloudWatch::Alarm",
    log_group_create: "AWS::Logs::LogGroup",
    secret_create: "AWS::SecretsManager::Secret",
    parameter_create: "AWS::SSM::Parameter",
    encryption_key_create: "AWS::KMS::Key"
  }

  @impl true
  def transform(%Graph{} = graph, opts \\ []) do
    with {:ok, sorted_ops} <- Graph.topological_sort(graph),
         {:ok, template} <- operations_to_template(sorted_ops, graph, opts),
         {:ok, output} <- format_template(template, opts) do
      {:ok, output}
    end
  end

  @impl true
  def validate(%Graph{} = graph) do
    case Graph.topological_sort(graph) do
      {:ok, _} -> :ok
      {:error, reason} -> {:error, {:invalid_graph, reason}}
    end
  end

  defp operations_to_template(operations, graph, opts) do
    description = Keyword.get(opts, :description, "Generated by HAR (Hybrid Automation Router)")

    # Build dependency map from graph edges
    dep_map = build_dependency_map(graph)

    resources =
      operations
      |> Enum.map(fn op -> operation_to_resource(op, dep_map) end)
      |> Enum.reject(&is_nil/1)
      |> Map.new()

    template = %{
      "AWSTemplateFormatVersion" => "2010-09-09",
      "Description" => description,
      "Resources" => resources
    }

    {:ok, template}
  end

  defp build_dependency_map(graph) do
    # Map from operation_id to list of logical IDs it depends on
    graph.edges
    |> Enum.group_by(fn dep -> dep.to end, fn dep -> dep.from end)
    |> Map.new(fn {to_id, from_ids} ->
      # Resolve from_ids to logical IDs
      logical_ids =
        Enum.flat_map(from_ids, fn from_id ->
          op = Enum.find(graph.vertices, fn v -> v.id == from_id end)
          if op do
            [generate_logical_id(op)]
          else
            []
          end
        end)

      {to_id, logical_ids}
    end)
  end

  defp operation_to_resource(op, dep_map) do
    resource_type = Map.get(@type_mappings, op.type)

    if resource_type do
      logical_id = generate_logical_id(op)
      properties = build_properties(op.type, op.params)
      depends_on = Map.get(dep_map, op.id, [])

      resource = %{
        "Type" => resource_type,
        "Properties" => properties
      }

      resource = if depends_on != [], do: Map.put(resource, "DependsOn", depends_on), else: resource

      {logical_id, resource}
    else
      Logger.debug("Skipping unsupported operation type for CloudFormation: #{op.type}")
      nil
    end
  end

  # Property building by operation type

  defp build_properties(:vm_create, params) do
    props = %{}
    props = add_if_present(props, "InstanceType", params[:instance_type] || "t3.micro")
    props = add_if_present(props, "ImageId", params[:image_id])
    props = add_if_present(props, "KeyName", params[:key_name])
    props = add_if_present(props, "SubnetId", params[:subnet_id])
    props = add_if_present(props, "SecurityGroupIds", params[:security_group_ids])
    props = add_if_present(props, "IamInstanceProfile", params[:iam_instance_profile])
    props = add_if_present(props, "UserData", params[:user_data])
    props = add_tags(props, params[:name], params[:tags])
    props
  end

  defp build_properties(:storage_bucket_create, params) do
    props = %{}
    props = add_if_present(props, "BucketName", params[:name])
    props = add_if_present(props, "AccessControl", params[:access_control])

    props = if params[:versioning] do
      Map.put(props, "VersioningConfiguration", %{"Status" => "Enabled"})
    else
      props
    end

    props = add_if_present(props, "BucketEncryption", params[:encryption])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:function_create, params) do
    props = %{}
    props = add_if_present(props, "FunctionName", params[:name])
    props = add_if_present(props, "Runtime", params[:runtime])
    props = add_if_present(props, "Handler", params[:handler])
    props = add_if_present(props, "Role", params[:role])
    props = add_if_present(props, "Code", params[:code])
    props = add_if_present(props, "MemorySize", params[:memory_size])
    props = add_if_present(props, "Timeout", params[:timeout])

    props = if params[:environment] do
      Map.put(props, "Environment", %{"Variables" => params[:environment]})
    else
      props
    end

    props = add_if_present(props, "VpcConfig", params[:vpc_config])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:database_create, params) do
    props = %{}
    props = add_if_present(props, "DBInstanceIdentifier", params[:name])
    props = add_if_present(props, "Engine", params[:engine] || "mysql")
    props = add_if_present(props, "EngineVersion", params[:engine_version])
    props = add_if_present(props, "DBInstanceClass", params[:instance_class] || "db.t3.micro")
    props = add_if_present(props, "AllocatedStorage", params[:allocated_storage] || 20)
    props = add_if_present(props, "MasterUsername", params[:master_username])
    props = add_if_present(props, "MasterUserPassword", params[:master_password])
    props = add_if_present(props, "VPCSecurityGroups", params[:vpc_security_groups])
    props = add_if_present(props, "DBSubnetGroupName", params[:db_subnet_group])
    props = add_if_present(props, "MultiAZ", params[:multi_az])
    props = add_if_present(props, "StorageEncrypted", params[:storage_encrypted])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:network_vpc_create, params) do
    props = %{}
    props = add_if_present(props, "CidrBlock", params[:cidr_block] || "10.0.0.0/16")
    props = add_if_present(props, "EnableDnsHostnames", params[:enable_dns_hostnames])
    props = add_if_present(props, "EnableDnsSupport", params[:enable_dns_support])
    props = add_if_present(props, "InstanceTenancy", params[:instance_tenancy])
    props = add_tags(props, params[:name], params[:tags])
    props
  end

  defp build_properties(:network_subnet_create, params) do
    props = %{}
    props = add_if_present(props, "VpcId", params[:vpc_id])
    props = add_if_present(props, "CidrBlock", params[:cidr_block])
    props = add_if_present(props, "AvailabilityZone", params[:availability_zone])
    props = add_if_present(props, "MapPublicIpOnLaunch", params[:map_public_ip_on_launch])
    props = add_tags(props, params[:name], params[:tags])
    props
  end

  defp build_properties(:security_group_create, params) do
    props = %{}
    props = add_if_present(props, "GroupName", params[:name])
    props = add_if_present(props, "GroupDescription", params[:description] || "Security Group")
    props = add_if_present(props, "VpcId", params[:vpc_id])
    props = add_if_present(props, "SecurityGroupIngress", params[:ingress_rules])
    props = add_if_present(props, "SecurityGroupEgress", params[:egress_rules])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:role_create, params) do
    props = %{}
    props = add_if_present(props, "RoleName", params[:name])
    props = add_if_present(props, "AssumeRolePolicyDocument", params[:assume_role_policy])
    props = add_if_present(props, "ManagedPolicyArns", params[:managed_policy_arns])
    props = add_if_present(props, "Policies", params[:policies])
    props = add_if_present(props, "Path", params[:path])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:database_table_create, params) do
    props = %{}
    props = add_if_present(props, "TableName", params[:name])
    props = add_if_present(props, "AttributeDefinitions", params[:attribute_definitions])
    props = add_if_present(props, "KeySchema", params[:key_schema])
    props = add_if_present(props, "BillingMode", params[:billing_mode])
    props = add_if_present(props, "ProvisionedThroughput", params[:provisioned_throughput])
    props = add_if_present(props, "GlobalSecondaryIndexes", params[:global_secondary_indexes])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:container_task_create, params) do
    props = %{}
    props = add_if_present(props, "Family", params[:family] || params[:name])
    props = add_if_present(props, "ContainerDefinitions", params[:container_definitions])
    props = add_if_present(props, "Cpu", params[:cpu])
    props = add_if_present(props, "Memory", params[:memory])
    props = add_if_present(props, "NetworkMode", params[:network_mode])
    props = add_if_present(props, "RequiresCompatibilities", params[:requires_compatibilities])
    props = add_if_present(props, "ExecutionRoleArn", params[:execution_role_arn])
    props = add_if_present(props, "TaskRoleArn", params[:task_role_arn])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:load_balancer_create, params) do
    props = %{}
    props = add_if_present(props, "Name", params[:name])
    props = add_if_present(props, "Type", params[:type])
    props = add_if_present(props, "Scheme", params[:scheme])
    props = add_if_present(props, "Subnets", params[:subnets])
    props = add_if_present(props, "SecurityGroups", params[:security_groups])
    props = add_if_present(props, "IpAddressType", params[:ip_address_type])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:queue_create, params) do
    props = %{}
    props = add_if_present(props, "QueueName", params[:name])
    props = add_if_present(props, "VisibilityTimeout", params[:visibility_timeout])
    props = add_if_present(props, "MessageRetentionPeriod", params[:message_retention_period])
    props = add_if_present(props, "DelaySeconds", params[:delay_seconds])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:notification_topic_create, params) do
    props = %{}
    props = add_if_present(props, "TopicName", params[:name])
    props = add_if_present(props, "DisplayName", params[:display_name])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:log_group_create, params) do
    props = %{}
    props = add_if_present(props, "LogGroupName", params[:name])
    props = add_if_present(props, "RetentionInDays", params[:retention_in_days])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(:secret_create, params) do
    props = %{}
    props = add_if_present(props, "Name", params[:name])
    props = add_if_present(props, "Description", params[:description])
    props = add_if_present(props, "SecretString", params[:secret_string])
    props = add_tags(props, nil, params[:tags])
    props
  end

  defp build_properties(_type, params) do
    # Generic fallback - convert params to properties
    params
    |> Map.delete(:name)
    |> Map.delete(:tags)
    |> Enum.map(fn {k, v} -> {camelize(to_string(k)), v} end)
    |> Map.new()
    |> add_tags(params[:name], params[:tags])
  end

  defp add_if_present(props, _key, nil), do: props
  defp add_if_present(props, _key, []), do: props
  defp add_if_present(props, _key, m) when is_map(m) and map_size(m) == 0, do: props
  defp add_if_present(props, key, value), do: Map.put(props, key, value)

  defp add_tags(props, name, tags) do
    tag_list = (tags || [])
    |> Enum.map(fn
      %{"Key" => k, "Value" => v} -> %{"Key" => k, "Value" => v}
      {k, v} -> %{"Key" => to_string(k), "Value" => to_string(v)}
      tag -> tag
    end)

    tag_list = if name do
      [%{"Key" => "Name", "Value" => name} | tag_list]
    else
      tag_list
    end

    if tag_list != [], do: Map.put(props, "Tags", tag_list), else: props
  end

  defp camelize(string) do
    string
    |> String.split("_")
    |> Enum.map(&String.capitalize/1)
    |> Enum.join("")
  end

  defp generate_logical_id(op) do
    name = op.params[:name] || op.metadata[:logical_id] || "Resource"

    name
    |> to_string()
    |> String.replace(~r/[^a-zA-Z0-9]/, "")
    |> String.slice(0, 50)
    |> ensure_starts_with_letter()
  end

  defp ensure_starts_with_letter(<<first, _rest::binary>> = str) when first >= ?0 and first <= ?9 do
    "R" <> str
  end
  defp ensure_starts_with_letter(str), do: str

  # Template formatting

  defp format_template(template, opts) do
    format = Keyword.get(opts, :format, :yaml)

    case format do
      :yaml -> format_yaml(template)
      :json -> format_json(template)
      _ -> format_yaml(template)
    end
  end

  defp format_yaml(template) do
    header = """
    # Generated by HAR (Hybrid Automation Router)
    # AWS CloudFormation Template
    """

    case HAR.Utils.YamlFormatter.to_yaml(template) do
      {:ok, yaml} -> {:ok, header <> yaml}
      {:error, reason} -> {:error, reason}
    end
  end

  defp format_json(template) do
    case Jason.encode(template, pretty: true) do
      {:ok, json} ->
        header = "// Generated by HAR (Hybrid Automation Router)\n// AWS CloudFormation Template\n"
        {:ok, header <> json}

      {:error, reason} ->
        {:error, reason}
    end
  end
end
